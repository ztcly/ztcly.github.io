[{"title":"适用于真寻bot的GTFO地图查询插件","url":"/2023/02/21/GTFOMapQQBotPlugin/","content":"摘要本文记录了适用于真寻bot的GTFO地图查询插件的相关信息\n\n\n说明本项目是一个适用于真寻Bot的GTFO地图查询插件。\n指令gtfo [地图名称]例：gtfo r7c1\n效果图\n地图来源Steam社区原链接 （R7）作者：Hunter48RUS,Artefas,livinghell  \nGithub链接Github链接\n","categories":["开发"],"tags":["Python"]},{"title":"Live2D新错误及修正","url":"/2023/02/20/Live2dError0220/","content":"摘要本文是在今天发现博客首页的Live2D再次出现故障并修复的过程记录。\n\n\n新的故障今天在准备进行更换博客的主题时，发现左下角的Live2D再次不能正常使用打开浏览器控制台：\n\n这次的报错是之前经历过的问题Uncaught SyntaxError: Unexpected token &#39;&lt;&#39;。但是由于之前已经将Api的目录模式关掉，故应当是传了别的东西过来。仔细检查报错的Autoload.js，首行明显出现一行画风不会的html。\n&lt;link rel=&#x27;stylesheet&#x27; type=&#x27;text/css&#x27; href=&#x27;https://cdn.jsdelivr.net/npm/hexo-tag-hint@$&#123;version&#125;/dist/hexo-tag-hint.min.css`&#x27;&gt;\n\n这一句已经清清楚楚的将故障的来源表明清楚：这次的故障可能是Hexo-tag-hint这个插件所引发的。\nHinthexo-tag-hint这个插件的作用在这句话中就能显示，点一下这句带着下划线的话就能看见。这句代码出现在这里，说明这个插件会向每个页面插入以让每个页面加载它所提供的css。但是很明显Live2d插件所使用的这些js文件不应在此列。使用VSCode的文件查询功能，在hint插件范围内查找插入这句html的代码。可以找到如下内容：\nhexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data) &#123;    data.content =        util.htmlTag(            &#x27;link&#x27;,            &#123;                rel: &#x27;stylesheet&#x27;,                type: &#x27;text/css&#x27;,                href: `https://cdn.jsdelivr.net/npm/hexo-tag-hint@$&#123;version&#125;/dist/hexo-tag-hint.min.css`            &#125;) +        data.content;    return data;&#125;);\n这里是一个Hexo的过滤器，我们可以查看Hexo的文档\n对于过滤器的声明给出的示例格式如下：\nhexo.extend.filter.register(type, function() &#123;  // User configuration  const &#123; config &#125; = this;  if (config.external_link.enable) // do something...  // Theme configuration  const &#123; config: themeCfg &#125; = this.theme;  if (themeCfg.fancybox) // do something...&#125;, priority);\n考虑插件中给出的Filter，查看文档给出的示例：  \n\nafter_post_renderExecuted after a post is rendered. Refer to post rendering to learn the execution steps.For example, to replace @username with a link to a Twitter profile:\n\nhexo.extend.filter.register(&#x27;after_post_render&#x27;, function(data)&#123;    data.content = data.content.replace(/@(\\d+)/, &#x27;&lt;a href=&quot;http://twitter.com/$1&quot;&gt;#$1&lt;/a&gt;&#x27;);    return data;&#125;);\n博客在生成时，会对文章进行渲染。而after_post_render过滤器则会在博文渲染完毕后触发。向其中插入html。接下来就是让js文件避免被进行渲染。\nHexo文件处理根据文档，Hexo对于source文件夹下的文件处理：\n\nSource folder. This is where you put your site’s content. Hexo ignores hidden files and files or folders whose names are prefixed with _ (underscore) - except the _posts folder. Renderable files (e.g. Markdown, HTML) will be processed and put into the public folder, while other files will simply be copied.\n\n接下来只需要让hexo在每次生成时将js文件原封不动的搬过去。参见文档的这一部分\n\nPaths that will be copied to public raw, without being rendered. You can use glob expressions for path matching.Examples:\n\nskip_render: &quot;mypage/**/*&quot;# will output `source/mypage/index.html` and `source/mypage/code.js` without altering them.## This also can be used to exclude posts,skip_render: &quot;_posts/test-post.md&quot;# will ignore the `source/_posts/test-post.md`.\n\n_找到配置文件_config.yml，并添加：  \nskip_render:  - &quot;**/*.js&quot;  - &quot;*/*.js&quot;\n\n搞定\n","categories":["建站"],"tags":["Live2D"]},{"title":"Minecraft1.19.3Fabric基础模组包","url":"/2023/02/16/MCFabric1.19.3BasicModPack/","content":"摘要Minecraft1.19.3Fabric基础模组包发布页面  \n\n\n模组包下载本次更新提供完整包下载和更新包下载，完整包适用于以前未安装过该整合包或想重新安装的玩家。更新包适用于以前安装过需要进行模组更新的玩家。\n\n完整模组包下载：\n\n下载完成后请遵循教程在启动器中导入整合包下载地址1：服务器下载地址2：百度网盘 提取码：qtmd  \n\n\n更新包下载：\n\n下载完成后请解压，找到你的MC根目录，将更新包提供的config文件夹和mods粘贴到mc根目录。正常情况下在粘贴文件时系统会提示你【是否覆盖文件】，需要选择【是】\n\n下载地址1：服务器下载地址2：百度网盘 提取码：cnmd\n模组包安装完整包安装请使用支持MCBBS整合包格式的启动器进行导入。通过PCL导入整合包可以参见：  \n\n        \n            \n                \n                \n                    \n                \n                00:06:30\n            \n            \n                【我的世界】整合包入门 如何导入整合包与整合包下载失败怎么办\n                \n                    \n                        \n                        1.6万\n                    \n                        \n                        16\n                \n                    视频\n                    \n                    阿白1号机\n                \n                \n            \n        \n    \n\n更新包安装更新包需要将更新内容复制粘贴进你之前安装的旧版本整合包根目录下。如果找不到可以借助启动器：PCL启动器：在启动器左下角选择【版本设置】，在新打开的界面中【快捷方式】一栏中点击【版本文件夹】即可打开根目录。BakaXL启动器：在启动器右下角启动游戏的按钮左侧有一个【切换Minecraft游戏核心】在列表中找到整合包（例如1.19.3——Fabric 0.14.13），在右侧的列表中点击【高级核心管理】在左侧的列表中找到【模组(Mods)】，最后选择【打开模组文件夹】。打开的文件夹便是模组文件夹，在打开的文件夹界面选择“上移一级”便是游戏根目录\n模组包新增内容急速滚轮模组为鼠标滚轮添加很多快捷操作。增加包括背包&#x2F;容器整理在内的功能。  \n\n背包&#x2F;容器整理功能默认在背包&#x2F;容器界面中单击鼠标中键  \n\n详细信息见下图，原链接：  \n\n\n注：在游戏内进行设置的Mod Menu模组已经安装\n\n快速交易模组现在在和村民交易时，只需要点击一次交易界面左侧的交易项就会进行一次交易。不需要再手动放置绿宝石或其它的交易物。  \n\n高级聊天核心&#x2F;HUD该模组更改了聊天界面，现在你可以像管理及时聊天软件的窗口一样管理多个聊天。聊天界面也会进行更新。同时为指令、聊天等提供高亮语法参考。\n\n高级聊天：配置方式如果在进入游戏之后，游戏界面只有正下方的输入框。那么你需要点击Main右边的加号【+】按钮添加聊天窗口。默认添加的是Main窗口，即服务器所有聊天。在Main对话窗口的右上角三个按钮中，最左侧的是设置聊天框的存在形式：  \n\n感叹号（推荐）：代表这个聊天窗口会在有新消息时和你开始输入聊天内容时出现。这也是最贴近原版的设置。\n方框：代表这个聊天窗口只会在你开始输入聊天内容时出现。\n大头针：代表这个方框会在游戏过程中一直出现。\n\n护甲栏优化模组现在护甲条将显示你身上装甲的材质和附魔状况。\n\n物品平滑移动现在物品在容器、背包等界面间移动时将会有一个平滑移动的动画。\n模组包原内容皮肤加载mod可以在服务器关闭正版验证的情况下正常加载玩家皮肤，并且可以使非正版玩家在皮肤站的皮肤可以显示。  \n效果图：  \n\n3D皮肤层mod可以将玩家皮肤的一层以3D的形式渲染，使得玩家皮肤更加立体，更加凹凸有致。  \n效果图：  \n\n对，没错，还是这张图。仔细看一看胸、胳膊和头，是不是有些地方凹凸有致？\n光影（可选）这就不用解释了，包内带了一个光影包，如果觉得卡顿可以自行关掉。  \n效果图：  \n\n钠这个Mod是光影的前置mod，但是对游戏进行了优化。可提高帧速率，优化一定性能并减少图象问题。\n耐久值显示这个mod会在界面上显示你的装备耐久等信息\n效果图：\n\n\n注：这里的0指的是掉了 0 点耐久，即满耐久\n\n工作方块3D材质这个小资源包会使一些工作方块更加立体，更加凹凸有致\n效果图：\n\n喜报由于大家的网络经常不是很好，会经常出现掉线的情况。喜报可以有效提升玩家掉线时的游戏体验。  \n效果图：  \n\n","categories":["游戏"],"tags":["Minecraft"]},{"title":"Minecraft1.19.3Fabric0216服务端 更新日志","url":"/2023/02/16/FabricServer1.19.3Update0216/","content":"摘要Minecraft1.19.3Fabric0216服务端 更新日志\n\n\n2023.2.25更新内容服务器权限系统更新\n现在所有人都不再是Minecraft原版的管理员(op)\n服务器管理将交由luckperms模组、MinecraftCommandPermissions模组进行管理\ntp指令、gamemode指令正常使用。\n其它部分特权指令如&#x2F;kill、&#x2F;ban、&#x2F;ban-ip、&#x2F;kick等指令正常情况下将无法使用\n大部分Essential Commands模组的指令正常使用（下文会提及)\n\n新增模组Essential Commands添加了一些简单的实用指令简单介绍：  \n家指令相关&#x2F;home set &lt;名称&gt; 设置家&#x2F;home list 家的列表&#x2F;home tp &lt;名称&gt; 传送至家  \n\n若只有一个家，则不用填写名称\n\n&#x2F;home delete &lt;名称&gt; 删除家  \n地标传送&#x2F;warp set &lt;名称&gt; 设置地标&#x2F;warp list 地标的列表&#x2F;warp tp &lt;名称&gt; 传送至地标  \n\n地标传送必须填写目标名称\n\n&#x2F;warp delete &lt;名称&gt; 删除地标  \n地标通常用于服务器基础公共设施，如农场等目前已经添加的地标：\n\n\n采用英文是为了可以使用Tab键自动补全  \n\n\nCapitolHill:国会山顶\nHugeFarm:城西的大农场\nCityDefenseControlCenter:城防控制中心\nDock:码头\nTheGreatHallogVillager:村民大会堂\nWC\nwarehouse:仓库\nCapitolHillFarm:国会山农场\n\n其它指令&#x2F;back 返回先前的位置&#x2F;rtp 随机传送一个位置\n添加模组luckperms和MinecraftCommandPermissions该模组将接管服务器权限设置\n2023.2.18更新内容移除服务端模组：BeautifiedChatServer该模组为聊天栏美化模组。会影响Ping Me模组（@功能）的正常运行。且所有人的聊天控制台均无法识别，同时影响Dynmap（动态地图）的聊天功能。\n移除服务端模组：Minecraft Multi-Threading该模组为多线程优化模组。一天崩服八次\n添加服务端模组：Krypton该模组会图示优化网络堆栈。更多介绍参见这里\n添加服务端模组：PhosphorPhosphor 是一个致力于优化 MC 中优化最差的部分——照明引擎来节省 CPU 并以此提高性能的模组。通过一些优化，提高了 MC 在照明引擎方面的性能，同时还修复了一些长期存在的照明错误。更多介绍参见这里\n添加服务端模组：LithiumLithium 是一个免费且开源的优化模组，与其它优化 Mod 不同，Lithium 致力于着一个标准，即在不修改原版游戏内容的前提下做出更多的优化改进更多介绍参见这里\n2023.2.16更新内容\n本文所添加的所有模组均为服务端模组，客户端无需变化\n\n添加@功能现在你可以在服务器聊天时@他人，对方会在物品栏上方收到提示，同时收到语音提示。\n\n添加网页地图现在在运行正常时，可以通过访问这里或将链接http://150.158.133.44:8123/复制到浏览器地址栏中进行访问。在这个地图中将可以看到服务器的地图和目前在线的玩家的位置以及游戏内的聊天。  \n地图分为平面模式、表面模式和洞穴模式。其中洞穴模式暂未在此服务器上渲染。\n平面模式示意：\n\n表面模式示意：\n\n添加Scaffolding Drops Nearby模组现在当玩家破坏最后一个脚手架时，上面的脚手架应该当掉落在第一个脚手架的周围不会遍地都是。\n\n注：该功能尚未测试\n\n添加Save and Load Inventories模组添加了保存和加载物品栏的指令，它允许玩家轻松的将当前物品栏内的物品保存到文件中，在需要时再从文件加载物品栏并列出当前保存的物品栏。详细操作参见mcmod百科该mod页面\n\n注：该功能尚未测试\n\n","categories":["游戏"],"tags":["Minecraft"]},{"title":"笔试笔记","url":"/2023/02/16/WrittenExamination/","content":"摘要本文为自用某笔试大纲及对应知识点。知识点内容根据各个教程收集整理。所有教程版权归各自作者所有。\n\nC语言程序设计C语言概述C语言是一种计算机程序设计语言。它既有高级语言的特点，又具有汇编语言的特点。它可以作为系统设计语言，编写工作系统应用程序，也可以作为应用程序设计语言，编写不依赖计算机硬件的应用程序.原链接  \n特点：\n\n易于学习。\n结构化语言。\n它产生高效率的程序。\n它可以处理底层的活动。\n它可以在多种计算机平台上编译。原链接\n\n数据类型此部分原链接\n基本类型基本类型可分为整数类型和浮点类型  \n整数类型\n\n\n类型\n取值范围\n\n\n\nchar\n-128 到 127 或 0 到 255\n\n\nunsigned char\n0 到 255\n\n\nsigned char\n-128 到 127\n\n\nint\n-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647\n\n\nunsigned int\n0 到 65,535 或 0 到 4,294,967,295\n\n\nshort\n-32,768 到 32,767\n\n\nunsigned short\n0 到 65,535\n\n\nlong\n-2,147,483,648 到 2,147,483,647\n\n\nunsigned long\n0 到 4,294,967,295\n\n\n\n注:各种类型的存储大小与系统位数有关\n\n浮点类型\n\n\n类型\n范围\n精度\n\n\n\nfloat\n1.2E-38 到 3.4E+38\n6 位有效位\n\n\ndouble\n2.3E-308 到 1.7E+308\n15 位有效位\n\n\nlong double\n.4E-4932 到 1.1E+4932\n19 位有效位\n\n\n获取储存大小使用sizeof(),表达式 sizeof(type) 得到对象或类型的存储字节大小.如：  \n#include &lt;stdio.h&gt;#include &lt;limits.h&gt; int main()&#123;   printf(&quot;大小 : %lu \\n&quot;, sizeof(int));   return 0;&#125;\n\nvoid 类型void 类型指定没有可用的值。通常用于以下三种情况下：\n\n函数返回为空。C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 void exit (int status);\n函数参数为空。 C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 int rand(void);\n指针指向 void。 类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 void *malloc( size_t size ); 返回指向 void 的指针，可以转换为任何数据类型。\n\n运算符与表达式运算符此部分原链接\n算术运算符\n\n\n运算符\n描述\n\n\n\n+\n把两个操作数相加\n\n\n-\n从第一个操作数中减去第二个操作数\n\n\n*\n把两个操作数相乘\n\n\n&#x2F;\n分子除以分母\n\n\n%\n取模运算符，整除后的余数\n\n\n++\n自增运算符，整数值增加 1\n\n\n--\n自减运算符，整数值减少 1\n\n\n\n\n\n运算符\n描述\n\n\n\na++\n先赋值后运算\n\n\n++a\n先运算后赋值\n\n\n关系运算符\n\n\n运算符\n描述\n\n\n\n&#x3D;&#x3D;\n检查两个操作数的值是否相等，如果相等则条件为真。\n\n\n!&#x3D;\n检查两个操作数的值是否相等，如果不相等则条件为真。\n\n\n&gt;\n检查左操作数的值是否大于右操作数的值，如果是则条件为真。\n\n\n&lt;\n检查左操作数的值是否小于右操作数的值，如果是则条件为真。\n\n\n&gt;&#x3D;\n检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。\n\n\n&lt;&#x3D;\n检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。\n\n\n逻辑运算符\n\n\n运算符\n描述\n\n\n\n&amp;&amp;\n逻辑与运算符。如果两个操作数都非零，则条件为真。\n\n\n||\n逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。\n\n\n!\n逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。\n\n\n位运算符位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：  \n\n\n\np\nq\np &amp; q\np | q\np ^ q\n\n\n\n0\n0\n0\n0\n0\n\n\n0\n1\n0\n1\n1\n\n\n1\n1\n1\n1\n0\n\n\n1\n0\n0\n1\n1\n\n\n\n假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：A &#x3D; 0011 1100B &#x3D; 0000 1101  \n\nA&amp;B &#x3D; 0000 1100A|B &#x3D; 0011 1101A^B &#x3D; 0011 0001~A  &#x3D; 1100 0011  \n\n下表显示了 C 语言支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则：\n\n\n\n运算符\n描述\n实例\n\n\n\n&amp;\n按位与操作，按二进制位进行”与”运算。运算规则：  0&amp;0&#x3D;0;  0&amp;1&#x3D;0;  1&amp;0&#x3D;0;  1&amp;1&#x3D;1;\n(A &amp; B) 将得到 12，即为 0000 1100\n\n\n|\n按位或运算符，按二进制位进行”或”运算。运算规则：  0\n0&#x3D;0;  0\n\n\n^\n异或运算符，按二进制位进行”异或”运算。运算规则：  0^0&#x3D;0;  0^1&#x3D;1;  1^0&#x3D;1;  1^1&#x3D;0;\n(A ^ B) 将得到 49，即为 0011 0001\n\n\n~\n取反运算符，按二进制位进行”取反”运算。运算规则：  ~1&#x3D;-2;   ~0&#x3D;-1;\n(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。\n\n\n&lt;&lt;\n二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）.\nA &lt;&lt; 2 将得到 240，即为 1111 0000\n\n\n&gt;&gt;\n二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。\nA &gt;&gt; 2 将得到 15，即为 0000 1111\n\n\n赋值运算符\n\n\n运算符\n描述\n实例\n\n\n\n&#x3D;\n简单的赋值运算符，把右边操作数的值赋给左边操作数\nC &#x3D; A + B 将把 A + B 的值赋给 C\n\n\n+&#x3D;\n加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数\nC +&#x3D; A 相当于 C &#x3D; C + A\n\n\n-&#x3D;\n减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数\nC -&#x3D; A 相当于 C &#x3D; C - A\n\n\n*&#x3D;\n乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数\nC *&#x3D; A 相当于 C &#x3D; C * A\n\n\n&#x2F;&#x3D;\n除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数\nC &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A\n\n\n%&#x3D;\n求模且赋值运算符，求两个操作数的模赋值给左边操作数\nC %&#x3D; A 相当于 C &#x3D; C % A\n\n\n&lt;&lt;&#x3D;\n左移且赋值运算符\nC &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2\n\n\n&gt;&gt;&#x3D;\n右移且赋值运算符\nC &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2\n\n\n&amp;&#x3D;\n按位与且赋值运算符\nC &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2\n\n\n^&#x3D;\n按位异或且赋值运算符\nC ^&#x3D; 2 等同于 C &#x3D; C ^ 2\n\n\n|&#x3D;\n按位或且赋值运算符\nC |&#x3D; 2 等同于 C &#x3D; C | 2\n\n\n杂项运算符\n\n\n运算符\n描述\n实例\n\n\n\nsizeof()\n返回变量的大小。\nsizeof(a) 将返回 4，其中 a 是整数。\n\n\n&amp;\n返回变量的地址.\n&amp;a; 将给出变量的实际地址。\n\n\n*\n指向一个变量。\n*a; 将指向一个变量。\n\n\n? :\n条件表达式\n如果条件为真 ? 则值为 X : 否则值为 Y\n\n\n表达式此部分原链接  \n什么是表达式？表达式是由一系列运算符（operators）和操作数（operands）组成的序列。这既是表达式的定义，同时也指明了表达式的组成成分。运算符指明了要进行何种运算和操作，而操作数则是运算符操作的对象。 \n表达式有什么作用（表达式的目的）？继续解读标准，可以看到表达式的目的有如下几个：  \n\n计算数值（computation of a value）。表达式“3+2”的目的就是计算数值3和2的和。与此同时，表达式同时也表示这个计算所得到的值。具体的可以参阅下面的“表达式的属性有哪些”小节。\n指明数据对象或者函数（designates an object or a function）例如程序中有int i;声明语句，那么表达式i&#x3D;3中子表达式i就指代i所代表的那个对象（object），即一块连续的内存空间。而在表达式&amp;printf中printf指代的是标准C库中的printf函数。\n产生副作用（generate side effects）副作用（side effects）就是运行时对数据对象或文件的修改。\n表达式 i &#x3D; 50的副作用是将变量i的值设置为50，这样说是不是让你感到惊讶呢？ 这怎么可能是副作用呢，看起来更像是主要目的啊！ 然而，从C的角度来看，主要的目的却是对表达式求值。  \n表达式printf(“ABC”)的值为3（实际打印的字符数，不包括字符’\\0’），副作用就是在标准输出设备上连续打印字符A、B和C。  \n注:并不是所有的表达式都有副作用，表达式2+3的值为5，但是没有任何副作用。\n\n\n以上目的的组合（combination）\n\n表达式的属性有哪些（表达式的属性）？任何表达式都有值和类型两个基本属性。\n循环控制循环语句允许我们多次执行一个语句或语句组此部分原链接  \n循环类型C 语言提供了以下几种循环类型:  \n\n\n\n循环类型\n描述\n\n\n\nwhile 循环\n当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。\n\n\nfor 循环\n多次执行一个语句序列，简化管理循环变量的代码。\n\n\ndo…while 循环\n除了它是在循环主体结尾测试条件外，其他与 while 语句类似。\n\n\n嵌套循环\n您可以在 while、for 或 do..while 循环内使用一个或多个循环。\n\n\n循环控制语句循环控制语句改变你代码的执行顺序,通过它们可以实现代码的跳转。C 提供了下列的循环控制语句：  \n\n\n\n控制语句\n描述\n\n\n\nbreak 语句\n终止循环或 switch 语句，程序流将继续执行紧接着循环或 switch 的下一条语句。\n\n\ncontinue 语句\n告诉一个循环体立刻停止本次循环迭代，重新开始下次循环迭代。\n\n\ngoto 语句\n将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。\n\n\n数组C 语言支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。  \n声明数组在 C 中要声明一个数组，需要指定元素的类型和元素的数量:type arrayName [ arraySize ];.这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C 数据类型。  \n访问数组元素数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如：double salary = balance[9];  \n多维数组C 语言支持多维数组。多维数组声明的一般形式如下：\ntype name[size1][size2]...[sizeN];\n\n二维数组多维数组最简单的形式是二维数组。一个二维数组，在本质上，是一个一维数组的列表。声明一个 x 行 y 列的二维整型数组，形式如下：  \ntype arrayName [ x ][ y ];\n\n其中，type 可以是任意有效的 C 数据类型，arrayName 是一个有效的 C 标识符。一个二维数组可以被认为是一个带有 x 行和 y 列的表格。下面是一个二维数组，包含 3 行和 4 列：  \nint x[3][4];\n\n数组作为参数如果您想要在函数中传递一个一维数组作为参数，您必须以下面三种方式来声明函数形式参数，这三种声明方式的结果是一样的，因为每种方式都会告诉编译器将要接收一个整型指针。同样地，您也可以传递一个多维数组作为形式参数。  \n方式 1形式参数是一个指针（您可以在下一章中学习到有关指针的知识）:  \nvoid myFunction(int *param)&#123;&#125;\n\n方式 2形式参数是一个已定义大小的数组：  \nvoid myFunction(int param[10])&#123;&#125;\n\n方式 3形式参数是一个未定义大小的数组：  \nvoid myFunction(int param[])&#123;&#125;\n\n函数函数是一组一起执行一个任务的语句。每个 C 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。C 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。  \n此部分原链接\n定义函数C 语言中的函数定义的一般形式如下：  \nreturn_type function_name( parameter list )&#123;   body of the function&#125;\n\n在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：\n\n返回类型：一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。\n函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。\n参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。函数主体：函数主体包含一组定义函数执行任务的语句。\n\n函数参数如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。当调用函数时，有两种向函数传递参数的方式：  \n\n\n\n调用类型\n描述\n\n\n\n传值调用\n该方法把参数的实际值复制给函数的形式参数。在这种情况下，修改函数内的形式参数不会影响实际参数。\n\n\n引用调用\n通过指针传递方式，形参为指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进行的操作。\n\n\n默认情况下，C 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的实际参数。  \n指针此部分原链接\n每一个变量都有一个内存位置，每一个内存位置都定义了可使用 &amp; 运算符访问的地址，它表示了在内存中的一个地址。  \n指针也就是内存地址，指针变量是用来存放内存地址的变量。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为：  \ntype *var_name;\n\n在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var_name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。  但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明：  \nint    *ip;    /* 一个整型的指针 */double *dp;    /* 一个 double 型的指针 */float  *fp;    /* 一个浮点型的指针 */char   *ch;    /* 一个字符型的指针 */\n\n所有实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，对应指针的值的类型都是一样的，都是一个代表内存地址的长的十六进制数。\n不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。\n指针使用实例#include &lt;stdio.h&gt; int main ()&#123;   int  var = 20;   /* 实际变量的声明 */   int  *ip;        /* 指针变量的声明 */    ip = &amp;var;  /* 在指针变量中存储 var 的地址 */    printf(&quot;var 变量的地址: %p\\n&quot;, &amp;var  );    /* 在指针变量中存储的地址 */   printf(&quot;ip 变量存储的地址: %p\\n&quot;, ip );    /* 使用指针访问值 */   printf(&quot;*ip 变量的值: %d\\n&quot;, *ip );    return 0;&#125;\n\n当上面的代码被编译和执行时，它会产生下列结果：  \nvar 变量的地址: 0x7ffeeef168d8ip 变量存储的地址: 0x7ffeeef168d8*ip 变量的值: 20\n\n指针的运算C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-。  \n假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：ptr++在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。  \n我们概括一下：  \n指针的每一次递增，它其实会指向下一个元素的存储单元。指针的每一次递减，它都会指向前一个元素的存储单元。指针在递增和递减时跳跃的字节数取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节。  \n指针的比较指针可以用关系运算符进行比较，如 &#x3D;&#x3D;、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。  \n结构体此部分原链接\nC 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。  \n定义结构为了定义结构，须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：  \nstruct tag &#123;     member-list    member-list     member-list      ...&#125; variable-list ;\n\n\ntag 是结构体标签。\nmember-list 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义。\nvariable-list 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。\n\n共用体共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。 共用体提供了一种使用相同的内存位置的有效方式。  \n定义共用体为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下：\nunion [union tag]&#123;   member definition;   member definition;   ...   member definition;&#125; [one or more union variables];\n\nunion tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str：\nunion Data&#123;   int i;   float f;   char  str[20];&#125; data;\n\n现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。  \n共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。  \n为了访问共用体的成员，我们使用成员访问运算符（.）\n#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data&#123;   int i;   float f;   char  str[20];&#125;; int main( )&#123;   union Data data;            data.i = 10;   data.f = 220.5;   strcpy( data.str, &quot;C Programming&quot;);    printf( &quot;data.i : %d\\n&quot;, data.i);   printf( &quot;data.f : %f\\n&quot;, data.f);   printf( &quot;data.str : %s\\n&quot;, data.str);    return 0;&#125;\n\n当上面的代码被编译和执行时，它会产生下列结果：  \ndata.i : 1917853763data.f : 4122360580327794860452759994368.000000data.str : C Programming\n\n\n计算机网络计算机网络体系结构此部分原链接\n计算机网络的体系结构是指这个计算机网络及其部件所应完成 的功能的一组抽象定义,是描述计算机网络通信方法的抽象模型结构,一般是指计算机网络的各层及其协议的集合。  \nOSI参考模型分层原则\n网中各结点都具有相同的层次\n不同结点的同等层具有相同的功能\n同一结点内相邻层之间通过接口通信\n每层可以使用下层提供的服务，并向其上层提供服务\n不同结点的对等层通过协议来实现对等层次之间的通信\n\n层次结构1.物理层:利用传输介质实现比特序列的传输（比特序列也就是二进制位），它需要为它的上层数据链路层提供服务。2.数据链路层：采用差错控制与流量控制方法，使得有差错的物理线路变成无差错的数据链路3.网络层(network layer):实现路由选择、分组转发与拥塞控制等功能，为“分组”传输选择“最佳”的路由4.运输层(transport layer):向高层用户提供可靠的“端-端”通信服务，向高层屏蔽下层数据通信的具体细节5.会话层(session layer):维护两个通信计算机之间的进程通信，管理数据交换6.表示层(presentation layer):处理两个通信的计算机系统的数据表示方式，完成数据的格式变换、加密与解密、压缩与恢复7.应用层(application layer):需要为用户提供一个平台，允许用户去开发能够满足自己需求的网络通讯。为应用软件提供多种网络服务，例如万维网、文件传输、电子邮件与其它服务等  \n\nTCP&#x2F;IP参考模型层次结构\n网络接口层是 TCP&#x2F;IP 参考模型的最低层，它负责通过网络发送和接收IP数据。\n\n互联网层:使用IP协议提供“尽力而为(best effort)”的网络分组传输服务。将运输层报文段封装成IP数据报，选择适当的发送路径并将数据报转发到下一个结点。（关键部分）\n\n运输层:负责在会话的进程之间建立和维护“端-端”的连接。定义了两种不同的协议:传输控制协议(TCP)与用户数据报协议(UDP)。（UDP特点是高效，对可靠性要求不高，但是对实时性要求比较高的传输。我们可以使用它为其服务，比如说传输语音，传输视频）\n\n应用层:和 OSI 参考模型的应用层类似，为应用软件提供多种网络服务\n\n\n\n物理层此部分原链接\n基本概念数据、信号与码元数据是传送信息的实体。信号则是数据的电气或电气表现，是数据在传输过程中的存在形式。连续变化的数据或信号称为模拟数据或模拟信号；取值仅允许为有限的几个离散数据的数据或信号称为数字数据或数字信号。数据的传输方式可分为串行传输和并行传输。串行传输是指1比特1地按照时间顺序传输（远距离通信通常采用串行传输），并行传输是指若干比特通过多条通信信道同时传输。码元是指用一个固定时长的信号波形（数字脉冲）表示一位k进制数字，代表不同离散数值的基本波形，是数字通信中数字信号的计量单位。时长内的信号称为k进制码元，该时长称为码元宽度。  \n信源、信道与信宿数据通信是指数字计算机或其他数字终端之间的通信，一个数据通信系统主要划分为信源、信道和信宿三部分。  \n信源是产生和发送数据的源头；信宿是接受数据的终点。  \n发送端信源发出的信息需要通过变换器转换成适合于在信道上传输的信号，而通过信道传输到接收端的信号先有反变换器转换成原始信息，再发送给信宿。\n信道与电路并不等同，信道是信号的传输媒介。一条通信线路往往包含一条发送信道和一条接收信道。噪声源是信道上的噪声（对信号的干扰）及分散在通信系统其他各处的噪声的集中表示。\n信道按传输信号形式的不同，可分为传送模拟信号的模拟信道和传送数字信号的数字信号两大类。\n信道按传输介质的不同可分为无线信道和有限信道。\n信道上传输的信号有基带信号和宽带信号之分。基带信号将数字信号1,0直接用两种不同的电压表示，传送到数字信道上传输（基带传输）；宽带信号将基带信号进行调制后形成频分复用模拟信号，送到模拟信道上传输（宽带传输）。\n从通信双方信息的交互方式看，可分为三种基本方式：\n\n单向通信。只有一个方向的通信而没有反方向的交互，仅需一条信道。如无线电广播、电视广播。\n半双工通信。通信的双方都可以发送和接受信息，但任何一方都不同同时发送和接受信息，因此需要两条信道。\n全双工通信。通信双方都可以同时发送和接受信息，需要两条信道。信道的极限容量是指信道的最高码元传输速率或信道的极限信息传输速率。\n\n速率、波特与带宽速率也称数据率，值数据传输速率，表示单位时间内传输的数据量。可用码元传输速率和信息传输速率表示。\n\n码元传输速率。又称波特率，表示单位时间内数字通信系统所传输的码元个数（也称脉冲个数或信号变化的次数）；单位波特（Baud）1波特表示数字通信系统传输一个码元；码元速率与进制数无关，可以是多进制的也可以是二进制的。\n信息传输速率。又称信息速率、比特率等，表示单位时间内数字通信系统传输的二进制码元格式（比特数），单位是比特&#x2F;秒（b&#x2F;s）注：波特和比特是两个不同的概念，码元传输速率也称调制速率、波形速率或符号速率。但码元传输速率与信息传输速率在数量却有一定关系。如一个码元携带n比特的信息量，则M波特率的码元传输速率所对应的信息传输速率为Mn比特&#x2F;秒。\n\n带宽原指信号具有的频带宽度，单位赫兹（Hz）。带宽与数据率存在数值上的互换关系，因此常用来表示网络的通信线路所能传输数据的能力。因此，带宽表示单位时间内从网络的某一点到另一点所能通过的最高数据率。此时带宽的单位不是Hz，而是b&#x2F;s。\n编码与调制数据无论是数字的还是模拟的，为了传输都必须转变为信号。把数据变换为模拟信号的过程称为调制，把数据变换为数字信号的过程称为编码。\n信号是数据的具体表现形式。数字数据可以通过数字发送器转换为数字信号传输，也可通过调制转换成模拟信号传输；同样的，模拟数据可以通过PCM编码器转换成数字信号传输，也可以通过放大器调制器转换成模拟信号传输。这样新城了下列4中编码方式。\n\n数字数据编码为数字信号数字数据编码用于基带传输中，在基本不改变数字信号数据频率情况下，直接传输数字信号。\n归零编码（RZ)。在RZ中用高电平电表1、低电平代表0（或者相反）。每个时钟周期的中间均跳变到低电平(归零)，接收方根据跳变调整本方的时钟基准，这为传输双方提供了自同步机制。但归零需要占用一定带宽，因此传输效率收到了一定的影响。\n非归零编码（NRZ）。NRZ与RZ区别是不用归零。一个周期可全部用来传输数据。但NRZ编码无法传递时钟信号，双方难以同步，若需传输告诉同步数据，需要都带有时钟线。\n反向非归零编码（NRZI）。NRZI与NRZ的区别是用信号的翻转代表0，信号保持不变代表1，翻转的信号本身可以作为一种通知机制。这种编码方式继承了前两种编码的优点，技能传输时钟信号，又能尽量不损失系统带宽。例如USB2.0的通信编码方式就是NRZI编码。\n曼切斯特编码。ME将一个码元分成两个相等的间隔。前一个为高电平而后一个为低电平表示码元1；码元0的表示方法正好相反。该编码特点是，在每个码元的中间出现电平跳变，位中间的跳变即作为时钟信号（可用于同步），有作为数据信号，但所占的频带宽度是原始频带宽度的两倍。例如以太网使用的编码方式就是曼切斯特编码。\n差分曼切斯特编码。常用于局域网传输。其规则为：若码元为1，则前半个码元的电平与上一码元的后半个码元的电平相同；若码元为0，则情形相反。该编码特点是，在每个码元中间都有一次电平的的跳转，可实现自同步，且抗干扰性较好。\n4B&#x2F;5B编码，将欲发数据流的每4位作为一组，按照4B&#x2F;5B编码规则将其转换成相应的5位码。5位码共32种组合。但只采用其中的16种对应16种不同的4位码，其他16种作为控制码或保留。\n\n\n数字数据调制为模拟信号数字数据调制技术在发送端将数字信号转换为模拟信号，而在接收端将模拟信号换源为数字信号，分别对应调制解调器的调制和解调过程。基本的数字调制方法有如下几种：\n幅移键控（ASK）。通过改变载波信号的振幅来表示数字信号1,和0，而载波的频率和相位都不改变。笔记容易实现，但抗干扰能力差。\n\n频移键控（FSK）。通过改变载波信号的频率来表示数字喜好1和0，而载波的振幅和相位都不改变，容易实现，抗干扰能力强，应用广泛。\n\n相移键控（PSK）。通过改变载波信号的相位来表示数字信号1和0，而载波的振幅和频率都不改变。它又分为绝对调相和相对调相。\n\n正交振幅调制（OAM）。在频率相同的前提下，将ASK和PSK结合起来，形成叠加信号。\n\n\n\n模拟数据编码为数字信号这种编码方式最典型的例子是常用于对音频信号进行编码的脉码调制（PCM）。主要包括三个步骤，采样、量化和编码。采样定理：将模拟信号转换成数字信号时，结社原始信号中的最大频率为f，那么采样频率f（采样）必须大于等于最大频率f的两倍，才能保证采样后的数字信号完整保留原始模拟信号的信息。采样定理又称为奈奎斯特定理。采样是指对模拟信号进行周期性扫描，把时间上连续的信号变成时间上离散的信号。根据采样定理，当采样的频率大于等于模拟数据的频带宽度（最高变化频率）的两倍时，所得的离散信号可以无失真地代表被采样的模拟数据。量化是把采样取得的点评幅值按照一定的分级标度转化为相应的数字值并取整数，这样就把连续的电平幅值转换为了离散的数字量。采样和量化的实质就是分割和转换。编码是把量化的结果转化为与之相对应的二进制编码。\n模拟数据调制为模拟信号为实现传输的有效性，可能需要较高的频率。这种调制方式可以使用频分复用(FDM)技术。充分利用带宽资源。例如电话机和本地局交换机采用模拟信号传输模拟数据的编码方式，模拟的声音数据时加载到模拟的载波信号中传输的。\n\n","categories":["开发"],"tags":["笔试","C语言"]},{"title":"部分插件用法及测试","url":"/2023/02/14/PluginTest/","content":"摘要本文记录了部分已经安装的实用插件及它们的用法\n\n\nBiliBili视频卡片插件Github链接  \n使用：在markdown文件中插入以下片段：  \n&#123;% bilicard your_video_id %&#125;\n\nyour_video_id 是b站的bv号或av号。  \n测试: \n\n        \n            \n                \n                \n                    \n                \n                00:20:05\n            \n            \n                【直播二周年】Defanive的生存世界游览！\n                \n                    \n                        \n                        1.7万\n                    \n                        \n                        569\n                \n                    视频\n                    \n                    夹绒飘雪D1rTysn0W\n                \n                \n            \n        \n    \n\n折叠插件Github链接  \n使用：在Markdown文件中插入以下片段：  \n&#123;% collapse(btn|link|card) HINT_SHOW HINT_HIDE %&#125;content&#123;% endcollapse(btn|link|card) %&#125;\n\n隐藏按钮测试：  \n\n    点击显示点击隐藏\n    \n        隐藏按钮测试\n\n    \n\n\n&#123;% collapsebtn &quot;点击显示&quot; &quot;点击隐藏&quot; %&#125;隐藏按钮测试&#123;% endcollapsebtn %&#125;\n\n隐藏链接测试：  \n\n      显示隐藏\n      \n          隐藏链接测试\n\n      \n  \n\n&#123;% collapselink 显示 隐藏 %&#125;隐藏链接测试&#123;% endcollapselink %&#125;\n\n隐藏卡片测试：  \n\n      &gt展开收起\n      \n          隐藏卡片测试\n\n      \n  \n\n&#123;% collapsecard 展开 收起 %&#125;隐藏卡片测试&#123;% endcollapsecard %&#125;\n\n嵌套隐藏测试：  \n\n      &gt展开收起\n      \n          \n      显示隐藏\n      \n          嵌套测试\n\n      \n  \n      \n  \n\n&#123;% collapsecard 展开 收起 %&#125;&#123;% collaspelink 显示 隐藏 %&#125;嵌套测试&#123;% endcollapselink %&#125;&#123;% endcollapsecard %&#125;\n\nSteam游戏信息卡片插件Github链接  \n使用：在Markdown文件中插入以下片段：单款游戏：  \n&#123;% steamgame appid description %&#125;\n\n多款游戏：  \n&#123;% steamgames %&#125;appidappidappidappidappidappid&#123;% endsteamgames %&#125;\n\n测试：  \n\n\n提示插件Github链接  \n使用：在Markdown文件中插入以下片段：  \n&#123;% hint &#x27;body_text&#x27; &#x27;hint_text&#x27; %&#125;&#123;% hint &#x27;body_text&#x27; &#x27;hint_text_1st_line&#x27; &#x27;hint_text_2nd_line&#x27; ... %&#125;\n\n测试：本博客基于 Hexo\n","categories":["开发"],"tags":["建站"]},{"title":"首篇文章：站点建立过程","url":"/2023/02/09/FirstPost/","content":"摘要本文记叙了站点从开始建立、配置首页Live2D插件&#x2F;脚本、在本地搭建Live2D Api遇到的问题和过程。本文约1.7K字，阅读时长约 5 分钟\n\n\n站点建立：顺利的前半程站点的博客部分采用hexo。通过hexo搭建博客已经有较为成熟的教程安装前置，再安装本体，最后选择一个好看的主题装上去（我在这里选择的是hexo-theme-melody）简单而方便的配置使得从我在搜索引擎敲下第一个问题“Hexo 搭建”到我能够开始写下这篇文档的前半部分只花了几十分钟——大部分时间还都在下载文件上。  \n一切都非常的顺利，直到我在好奇中看到了melody主题配置的额外选项Live2D Model\n弄个Live2D：探索的后半程看到Live2D模块的效果图，我也想打算整一个根据教程的指导，需要输入指令\nnpm install --save hexo-helper-live2d\n\n问题从这里就开始了，下载完成之后报了错\n错误大概长这个样子：\nXX vulnerabilities (XX moderate, X high, X critical) To address all issues (including breaking changes), run: npm audit fix --force Run `npm audit` for details.\n\n这里的意思是说npm安装时发现了很多漏洞，这里会显示出现问题的数量和等级。通过搜索引擎的查找，解决方案是npm audit fix→npm audit fix --force等指令。在执行的指令的时候，系统会给出各个问题的详情和修复。有的问题通过npm audit fix就可以修复，有的问题需要npm audit fix --force能进行修复，而还有很多问题根本没有给出修复。  \n在项目的Github页面上显示它已经不再维护，可以用另一个相似的项目Live2D Widget\n所以，安装进行到这里我选择换用Live2D Widget在Live2D Widget的页面说明中，应当把\n&lt;script src=&quot;https://fastly.jsdelivr.net/gh/stevenjoezhang/live2d-widget@latest/autoload.js&quot;&gt;&lt;/script&gt;\n\n加入到页面的&lt;head&gt;或者&lt;body&gt;中，如果使用的是 Hexo，那么需要在主题的模版文件中添加以上代码。\n那么下一步是寻找主题的模板文件：melody主题的特性页面有提到使用了pug模板引擎。再对pug进行搜索，可以看到在主题的layout文件夹下有很多pug，根据文件名和文件夹名推测这里便是存储模板文件的地方。\n\n这里服务器是Windows Server 2022，选择这个系统另有原因\n\n\n考虑到我的目的是在主页添加Live2D，现在应当对index.pug进行编辑。index.pug的内容打开如下：\nextends includes/layout.pugblock content  include includes/recent-posts.pug  include includes/pagination.pug\n\n截止到这里，我目前对于pug的语法还是一无所知。好在我需要进行的不是什么复杂操作，可以通过分析别的文件来推测如何操作。我的目标操作是添加一个&lt;script&gt;进去，所以在这里使用VS Code的多文件查找功能查找script关键词。在多个文件中我看到了这样的写法：\nscript(src=...)\n\n将src补充完整可得\nscript(src=&quot;http://localhost:4000/live2d-widget-master/autoload.js&quot;)\n\n最后将语句放入index.pug，重新生成并部署。\n成功了，但只成功了一半页面刷新完成之后，左下角成功出现了对话框、功能按钮等等组件。可唯独图片没有显示，空无一物。再继续对新的问题进行搜索，这次在issue和下方回复中的另一个帖子中找到了问题所在  \n\n然鹅，之前展示的好好的萌娘这次几乎全挂，又或者加载很慢，究其原因还是因为jsdeliver提供的cdn服务在中国被软墙，将后端api由jsdeliver更换为fghrsh提供的后端之后有所改善，但由于前端代码也挂载在jsdeliver，因此依然可能出现无法稳定加载的问题。最后还是将所有资源挂载到了本地才解决这一问题。 \n原文:live2d部署实践\n\n帖子的作者提供了自建的api，但考虑到为了让自己站点的Live2的访问更稳定，最终还是选择试着将模型文件存储在本地。\n在插件的Github页面有提到过live2d_api相关的内容,将这个后端api下载到本地发现是一堆的php文件。对于php我依旧是知之甚少，所以对于这个东西的运行只能继续求助于搜索引擎。搜索引擎的很多回答都提到了构建一个Apache+PHP+MySQL环境的教程。考虑到这个api用不到MySQL，先安装Apache和PHP环境。下载并解压二者，随后开始配置。Apache需要先指定目录：\nDefine SRVROOT &quot;C:/Users/ztcly/Apache24&quot;\n\nApache需要php模块：  \n\n这里如果加载的是php7的话，应当写LoadModule php7_module &quot;...&quot;\n\nLoadModule php_module &quot;C:/Users/ztcly/php-8.2.1-Win32-vs16-x64/php8apache2_4.dll&quot; PHPIniDir &quot;C:/Users/ztcly/php-8.2.1-Win32-vs16-x64&quot;AddType application/x-httpd-php .php .html .htm\n\n按照教程，php文件应该放在/htdocs目录下：\nDocumentRoot &quot;$&#123;SRVROOT&#125;/htdocs&quot;\n\n创建完成之后启动Apache，待服务正常启动。之后根据api教程中的说明更改Autoload.js中的apiPath字段，将其更改成Apache的地址和端口号，最后刷新页面。  \n老问题刷新页面之后，模型的位置依旧是空白。但是这次在浏览器控制台的报错就是我所认识的了,它大概长这个样子:\nAccess to XMLHttpRequest at ‘xxx’ from origin ‘xxx’ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource.\n\n这是十分明显的跨域问题，请求被CORS策略所阻止了。修改Apache&#x2F;htdocs的CORS策略(xxxx为来源)：\nDocumentRoot &quot;$&#123;SRVROOT&#125;/htdocs&quot;&lt;Directory &quot;$&#123;SRVROOT&#125;/htdocs&quot;&gt;    ExecCGI MultiViews    Options Indexes FollowSymLinks    AllowOverride None    Header set Access-Control-Allow-Origin xxxx    Require all granted    Allow from xxxx&lt;/Directory&gt;\n\n继续重启服务，重新生成，再部署——还是不能用检查控制台报错：Uncaught SyntaxError: Unexpected token &#39;&lt;&#39;\n等会，它给我传了点什么过来？问题就出在上面那段配置中——Options Indexes FollowSymLinks这里Indexes的作用就是当该目录下没有指定 index.html 文件时，就显示目录结构。也就是它传过来的东西是htdocs下的目录结构，以HTML形式。报错中提到的’&lt;’就是&lt;!DOCTYPE html&gt;左边的”&lt;”\n删除掉Indexes，并且为这个api指定一个用不上的首页：\n&lt;?phpphpinfo();?&gt;\n\n最后重启，终于成功了，芜湖\n\n","categories":["开发"],"tags":["建站"]}]